<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Edit this PDF</title>
  <script type="text/javascript" src="https://unpkg.com/html2canvas@1.0.0-rc.1/dist/html2canvas.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@2.8.335/build/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/CanvasInput/1.2.7/CanvasInput.js"></script>
<script type="text/javascript">

    // Variables for referencing the canvas and 2dcanvas context
    var canvas,ctx;
    var fontName = 'Arial';
    var fontSize = 16;
    var fontColor = '#212121';
    // Variables to keep track of the mouse position and left-button status
    var mouseX,mouseY,mouseDown=0;

    // Variables to keep track of the touch position
    var touchX,touchY;
    var textboxes = [];
    var pagenum = 1;
    // Draws a dot at a specific position on the supplied canvas name
    // Parameters are: A canvas context, the x position, the y position, the size of the dot
    function drawDot(ctx,x,y,size) {
        // Let's use black by setting RGB values to 0, and 255 alpha (completely opaque)
        r=0; g=0; b=0; a=255;

        // Select a fill style
        ctx.fillStyle = "rgba("+r+","+g+","+b+","+(a/255)+")";

        // Draw a filled circle
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI*2, true);
        ctx.closePath();
        ctx.fill();
    }

    // Clear the canvas context using the canvas width and height
    function clearCanvas(canvas,ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // Keep track of the mouse button being pressed and draw a dot at current location
    function sketchpad_mouseDown(canvas_name) {
        mouseDown=1;
        textboxes.push(makeTextBox(canvas_name, mouseX, mouseY));
        setTimeout(function() {
          textboxes[textboxes.length-1].focus();
        }, 500);
        // drawDot(ctx,mouseX,mouseY,12);
    }

    // Keep track of the mouse button being released
    function sketchpad_mouseUp() {
        mouseDown=0;
    }

    // Keep track of the mouse position and draw a dot if mouse button is currently pressed
    function sketchpad_mouseMove(e) {
        // Update the mouse co-ordinates when moved
        getMousePos(e);

        // Draw a dot if the mouse button is currently being pressed
        if (mouseDown==1) {
            // drawDot(ctx,mouseX,mouseY,12);
        }
    }

    // Get the current mouse position relative to the top-left of the canvas
    function getMousePos(e) {
        if (!e)
            var e = event;

        if (e.offsetX) {
            mouseX = e.offsetX;
            mouseY = e.offsetY;
        }
        else if (e.layerX) {
            mouseX = e.layerX;
            mouseY = e.layerY;
        }
     }

    // Draw something when a touch start is detected
    function sketchpad_touchStart() {
        // Update the touch co-ordinates
        getTouchPos();

        // drawDot(ctx,touchX,touchY,12);

        // Prevents an additional mousedown event being triggered
        event.preventDefault();
    }

    // Draw something and prevent the default scrolling when touch movement is detected
    function sketchpad_touchMove(e) {
        // Update the touch co-ordinates
        getTouchPos(e);

        // During a touchmove event, unlike a mousemove event, we don't need to check if the touch is engaged, since there will always be contact with the screen by definition.
        // drawDot(ctx,touchX,touchY,12);

        // Prevent a scrolling action as a result of this touchmove triggering.
        event.preventDefault();
    }

    // Get the touch position relative to the top-left of the canvas
    // When we get the raw values of pageX and pageY below, they take into account the scrolling on the page
    // but not the position relative to our target div. We'll adjust them using "target.offsetLeft" and
    // "target.offsetTop" to get the correct values in relation to the top left of the canvas.
    function getTouchPos(e) {
        if (!e)
            var e = event;

        if(e.touches) {
            if (e.touches.length == 1) { // Only deal with one finger
                var touch = e.touches[0]; // Get the information for finger #1
                touchX=touch.pageX-touch.target.offsetLeft;
                touchY=touch.pageY-touch.target.offsetTop;
            }
        }
    }

function makeTextBox(canvas_name, textbox_x, textbox_y){
  console.log(fontName)
  var textbox = new CanvasInput({
    canvas: document.getElementById(canvas_name),
    x: textbox_x,
    y: textbox_y,
    fontSize: fontSize,
    fontFamily: fontName,
    fontColor: fontColor,
    fontWeight: 'normal',
    width: 300,
    padding: 0,
    borderWidth: 0,
    borderRadius: 0,
    borderColor: 'rgba(0, 0, 0, 0)',
    innerShadow: '0px 0px 0px rgba(0, 0, 0, 0)',
    boxShadow: '0px 0px 0px rgba(0, 0, 0, 0)',
    placeHolder: 'Enter text'
  });
  return textbox
}

pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@2.8.335/build/pdf.worker.min.js";
var BASE64_MARKER = ';base64,';

function convertDataURIToBinary(dataURI) {
  var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
  var base64 = dataURI.substring(base64Index);
  var raw = window.atob(base64);
  var rawLength = raw.length;
  var array = new Uint8Array(new ArrayBuffer(rawLength));

  for(var i = 0; i < rawLength; i++) {
    array[i] = raw.charCodeAt(i);
  }
  return array;
}

function drawPdfInCanvas(page, pagenum) {
  var scale = 1.5;
  //
  // Prepare canvas using PDF page dimensions
  //
  var canvas = document.getElementById("page"+pagenum);
  var context = canvas.getContext('2d');
  canvas.height = page.height * scale;
  canvas.width = page.width * scale;
  //
  // Render PDF page into canvas context
  //
  var viewport = page.getViewport({ scale: scale, });
  canvas.height = viewport.height;
  canvas.width = viewport.width;

  var renderContext = {
  canvasContext: context,
  viewport: viewport
  };
  page.render(renderContext);
}

function streamPdf(file) {
  // Need to convert PDF file into Base64 data stream so that it can be loaded by pdfjs
  var reader = new FileReader();
  reader.readAsDataURL(file);
  reader.onload = function () {
    var pdfAsDataUri = reader.result
    var pdfAsArray = convertDataURIToBinary(pdfAsDataUri);
    // var loadingTask = pdfjsLib.getDocument(pdfAsArray);
    var loadingTask = pdfjsLib.getDocument(pdfAsArray);
    loadingTask.promise.then(function(pdf) {
      const domTarget = document.querySelector('#saveme');

      for (var i = 0; i < pdf.numPages; i++) {
        const newCanvas = document.createElement('canvas');
        newCanvas.id = "page" + i;
        newCanvas.height = "500"
        newCanvas.width = "600"
        newCanvas.style="border: 1px solid black; direction: ltr;"
        domTarget.appendChild(newCanvas);

        var page = pdf.getPage(i+1).then(
          function(page) {
            drawPdfInCanvas(page, page._pageIndex);
        }).catch(function(err) {
          console.log(err);
          console.log(page);
        });
        // Get the specific canvas element from the HTML document
        canvas = document.getElementById('page' + i);

        // If the browser supports the canvas tag, get the 2d drawing context for this canvas
        if (canvas.getContext)
            ctx = canvas.getContext('2d');

        // Check that we have a valid context to draw on/with before adding event handlers
        if (ctx) {
            // React to mouse events on the canvas, and mouseup on the entire document
            canvas.addEventListener('mousedown', sketchpad_mouseDown.bind(null,'page'+i), false);
            canvas.addEventListener('mousemove', sketchpad_mouseMove, false);
            window.addEventListener('mouseup', sketchpad_mouseUp, false);

            // React to touch events on the canvas
            canvas.addEventListener('touchstart', sketchpad_touchStart, false);
            canvas.addEventListener('touchmove', sketchpad_touchMove, false);
        }
      }
    });
  };
  reader.onerror = function (error) {
    console.log('Error: ', error);
  };
};

async function readPdf(){
  var file = document.querySelector('#files');
  streamPdf(file.files[0]);
}

// Set-up the canvas and add our event handlers after the page has loaded
function init() {
  document.querySelector("#loadpdf").addEventListener("click", function() {
    readPdf();
  });

  document.querySelector("#savepdf").addEventListener("click", function() {
    console.log("save pdf");
    var doc = new jspdf.jsPDF('p', 'mm', 'a4');

    canvases = document.querySelectorAll("[id^='page']");
    doc.addImage(canvases[0].toDataURL('image/png'), 'PNG', 0, 0, 210, 297);

    for (var i = 1; i < canvases.length; i++) {
      doc.addPage('p','pt','a4');
      doc.addImage(canvases[i].toDataURL('image/png'), 'PNG', 0, 0, 210, 297);
    };
    doc.save("Edited - " + document.querySelector('#files').value.split(/(\\|\/)/g).pop());
  });

  document.querySelector("select").addEventListener("change", function(fontSelector) {
    fontName = fontSelector.target.value;
  });
  document.querySelector("#fontSize").addEventListener("change", function(fontSizeSelector) {
    fontSize = fontSizeSelector.target.value;
    console.log(fontSize);
  });
}

</script>

</head>
<body onload="init()">

<h1>Edit this PDF</h1>
<label for="files">Select a file:</label>
<input type="file" id="files" name="files">
<br>
<button id="loadpdf">load pdf</button>
<button id="savepdf">save pdf</button>
<br>
Font:
<select>
    <option>Arial</option>
    <option>Tahoma</option>
    <option>Times New Roman</option>
    <option>Verdana</option>
</select>
Font size: <input type="number" id="fontSize" min="1" max="75" value=16>
<br>
<div id="saveme">
</div>


<script id="script">

</script>


</body>
</html>
